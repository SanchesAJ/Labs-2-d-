#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "pqeue.h"


//////////////////////////////////////////STACK///////////////////////////////////
typedef struct _List {
	hufftreeNode *val;
	struct _List *next;
} List;
typedef struct _Stack {
	List *head;
} Stack;
typedef enum ErrorCode {
	GOOD,
	MEMORY_ERROR,
	VOID,
	NO
} Error;
List *createList(hufftreeNode *value) {
	List *l = malloc(sizeof(List));
	if (l == NULL) {
		printf("Error");
		return NULL;
	}
	l->val = value;
	l->next = NULL;
	return l;
}
Error pushStack(Stack *s, hufftreeNode *el) {
	List *l = createList(el);
	if (l == NULL)
		return MEMORY_ERROR;
	l->next = s->head;
	s->head = l;
	return GOOD;
}
int isEmptyStack(Stack *f) {
	return f->head == NULL ? 1 : 0;
}
char peekStack(Stack *s) {
	if ((s->head->val) == NULL)
		return NULL;
	else
		return s->head->val;
}
Error popStack(Stack *s, hufftreeNode *a) {
	if (s->head == NULL)
		return VOID;
	a = s->head->val;
	List *oldHead = s->head;
	s->head = s->head->next;
	free(oldHead);
	return GOOD;
}
//////////////////////////////////////////////////////////////////////////////////



typedef struct _bitCotx {
	int pos;
	unsigned char str;
	FILE *out;
} BitCotx;


////////////////////////////////////////////////////////////TRAINING/////////////////////////////////////////////////////////////////////////
typedef struct _BinTable {
	unsigned char symbol;
	unsigned char StrTable[100];
} BinTable;

hufftreeNode *CreateCodeTree(Pqueue *templ) {
	while (!isLast(&templ)) {
		hufftreeNode *One = pop(&templ);
		hufftreeNode *Two = pop(&templ);
		push(&templ, NULL, (One->priority) + (Two->priority), One, Two);
	}
	return pop(&templ);
}
hufftreeNode *Training(FILE *input) {
	//Устанавливаем частоту символов
	unsigned char t;
	fscanf(input, "%c", &t);
	int Alphabet[257];
	for (int i = 0; i < 256; i++)
		Alphabet[i] = 0;
	int j = 0;
	while (!feof(input)) {
		int temp = fgetc(input);
		for (j = 0; j < 256; ++j) {
			if (temp == j) {
				++Alphabet[j];
				break;
			}
		}
	}
	Alphabet[j]--;


	// Создание очереди.
	int i; Pqueue *Collum=NULL;
	for (i = 0; i < 256; ++i) {
		if (Alphabet[i] != 0) {
			Collum = newPqueue(i, Alphabet[i], NULL, NULL);
			break;
		}
	}
	if (Collum == NULL) {
		exit(0);
	}
	int y = 0;
	for (i = 0; i < 256; ++i) {
		if (Alphabet[i] != 0) {
			push(&Collum, i, Alphabet[i], NULL, NULL);
			y++;
		}
	}
	
	pop(&Collum);
	//// Создаём дерево
	return CreateCodeTree(Collum);;
}
int count = 0;
void printTree(hufftreeNode *Tree, FILE *output) {
	if (Tree->value == '\0') {
		fprintf(output, "0");// Код "Создай узел"
		//printf("0");
	}

	if ((Tree->left) != NULL) {
		if (Tree->left->value == '\0') {
			fprintf(output, "0");
			//printf("0");
			printTree(Tree->left->left, output);
			printTree(Tree->left->right, output);
		}
		else {
			if (Tree->left->value != '\0') {
				fprintf(output, "1");// Код "Создай лист"
				fprintf(output, "%c", Tree->left->value);
				//printf("1");
				//printf("%c", Tree->left->value);
				count++;

			}
		}


	}
	else {
		if (Tree->value != '\0') {
			fprintf(output, "1");// Код "Создай лист"
			fprintf(output, "%c", Tree->value);
			//printf("1");
			//printf("%c", Tree->value);
			count++;
			return;
		}
	}

	if ((Tree->right) != NULL) {
		if (Tree->right->value == '\0') {

			fprintf(output, "0");
			//printf("0");
			printTree(Tree->right->left, output);
			printTree(Tree->right->right, output);
		}
		else {
			if (Tree->right->value != '\0') {
				fprintf(output, "1");// Код "Создай лист"
				//printf("1");
				//printf("%c", Tree->right->value);
				fprintf(output, "%c", Tree->right->value);
				count++;

			}
		}

	}
	else {
		if (Tree->value != '\0') {
			fprintf(output, "1");// Код "Создай лист"
			//printf("1");
			//printf("%c", Tree->value);
			fprintf(output, "%c", Tree->value);
			count++;
			return;
		}
	}
	return;
}
int coin; unsigned char str[256]; int pit = 0;
void CreateCodeTable(hufftreeNode *Tree, BinTable *Table, int num) {
	coin = num;
	if ((Tree->left) != NULL) {
		if (coin < 0)
			coin++;
		str[coin] = '0';
		coin++;
		if (Tree->left->value == '\0') {
			str[coin] = '0';
			coin++;
			CreateCodeTable(Tree->left->left, Table, coin);

			str[coin] = '1';
			coin++;

			CreateCodeTable(Tree->left->right, Table, coin);
			//coin--;
			//str[coin] = '\0';
			coin--;
			if (coin >= 0)
				str[coin] = '\0';
		}
		else {
			if (Tree->left->value != '\0') {
				/*str[coin] = '0';
				coin++;
				str[coin] = '\0';*/
				Table[pit].symbol = Tree->left->value;
				strcpy(Table[pit].StrTable, str);
				//printf("%c %s\n", Tree->left->value, str);
				pit++;
				coin--;
				if (coin >= 0)
					str[coin] = '\0';

			}
		}
	}
	else {
		if (Tree->value != '\0') {
			
			
			str[coin] = '\0';
			Table[pit].symbol = Tree->value;
			strcpy(Table[pit].StrTable, str);
			//printf("%c %s\n", Tree->value, str);
			pit++;
			coin--;
			if (coin >= 0)
				str[coin] = '\0';
			return;
		}
	}

	if ((Tree->right) != NULL) {
		if (coin < 0)
			coin++;
		str[coin] = '1';
		coin++;
		if (Tree->right->value == '\0') {
			str[coin] = '0';
			coin++;
			CreateCodeTable(Tree->right->left, Table, coin);
			//coin--;
			//str[coin] = '\0';
			str[coin] = '1';
			coin++;
			CreateCodeTable(Tree->right->right, Table, coin);
			if (coin >= 3) {
				coin--;
				str[coin] = '\0';
			}
			coin--;
			if (coin >= 0)
				str[coin] = '\0';
		}
		else {
			if (Tree->right->value != '\0') {
				/*str[coin] = '1';
				coin++;
				str[coin] = '\0';*/
				Table[pit].symbol = Tree->right->value;
				strcpy(Table[pit].StrTable, str);
				//printf("%c %s\n", Tree->right->value, str);

				pit++;
				coin--;
				if (coin >= 0)
					str[coin] = '\0';

			}
		}
	}
	else {
		if (Tree->value != '\0') {

			str[coin] = '\0';
			Table[pit].symbol = Tree->value;
			strcpy(Table[pit].StrTable, str);
			//printf("%c %s\n", Tree->value, str);
			pit++;
			coin--;
			str[coin] = '\0';
			return;
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
hufftreeNode *readTree(FILE *input, hufftreeNode *Tree) {
	hufftreeNode *node=calloc(1,sizeof(hufftreeNode));
	int c = fgetc(input);
	if (c == EOF)
		return NULL;
	count++;
	if (c=='1') {
		c = fgetc(input);
		count++;
		node = newHuffNode(c, 0, NULL, NULL);
	}
	else {
		node = newHuffNode('\0', 0, NULL, NULL);
		node->left = readTree(input, node);
		node->right = readTree(input, node);
	}
	return node;
}
/*
char writeSymbol(unsigned char *str, FILE *out, BinTable *MainTable) {
	for (int i = 0; i < pit; i++) {
		if (strcmp(str, MainTable[i].StrTable)==0) {
			fprintf(out, "%c", str);
			return i;
		}
	}
	return 0;
}*/

hufftreeNode *GoTree(unsigned char code, hufftreeNode *Node, FILE *out) {
	if (code == 0) {
		if (Node->left != NULL)
			Node = Node->left;
		if (Node->value != '\0') {
			fputc(Node->value, out);
			return NULL;
		}
		else return Node;
	}
	if (code == 1) {
		if (Node->right != NULL)
			Node = Node->right;
		if (Node->value != '\0') {
			//fprintf(out, "%c", Node->value);
			fputc(Node->value, out);
			//fwrite(&(Node->value), sizeof(char), 1, out);
			return NULL;
		}
		else return Node;
	}
}
	


void decode(FILE *input) {
	
	fgetc(input);
	hufftreeNode *Tree = NULL;
	Tree=readTree(input, NULL);
	if (Tree == NULL) {
		exit(0);
	}
	//РАБОТАЕТ
	
	unsigned char q=fgetc(input);
	q=fgetc(input);
	
	
	FILE *out = fopen("out.txt", "w");
	int c;
	int pos = 7;
	 unsigned char r; 
	 unsigned char b;
	 hufftreeNode *Temp = Tree;
	 int tempNext;
	 unsigned char miss = 0;
	 int temp;
	while ((c = fgetc(input)) != EOF) {
		temp = fgetc(input);
			 tempNext = fgetc(input);
			fseek(input, -2, SEEK_CUR);
			
		
		if (tempNext == EOF) {
			miss = temp;
			temp = miss - '0';
			if (temp <= 8 && temp>0) {
				for (int u = 0; u < 8 - temp; u++) {
					b = (char)c;
					r = (c >> pos - u) % 2;
					Temp = GoTree(r, Temp, out);
					if (Temp == NULL)
						Temp = Tree;

				}
				break;
			}
		}
		for (int u = 0; u < 8; u++) {
			b = (char)c;
			r = (c >> pos-u)%2;
			Temp = GoTree(r, Temp, out);
			if (Temp == NULL)
				Temp = Tree;
			
		}

	}
	//fputc("\r", out);
}


////////////////////////////////////////////////////////////////ENCODING///////////////////////////////////////////////////////////////////////
void writeBit(unsigned char code, BitCotx *bitCtx) {
	if (code == '1') {
		bitCtx->str |=1 << (7 - (bitCtx->pos));
		bitCtx->pos++;
	}
	else
		bitCtx->pos++;
	if (bitCtx->pos == 8) {
		fputc(bitCtx->str, bitCtx->out);
		bitCtx->pos = 0;
		bitCtx->str = '\0';
	}

}
void encode(FILE *input) {
	//Training to main encoding
	hufftreeNode *Code = Training(input);
	fclose(input);
	FILE *out = fopen("out.txt", "w");
	printTree(Code, out);
	fprintf(out, "\n\n");
	fclose(out);
	BinTable *MainTable = calloc(count, sizeof(BinTable));
	hufftreeNode *CodeTwo = Code;
	if (CodeTwo->value == '\0')
		CreateCodeTable(CodeTwo, MainTable, 0); //РАБОТАЕТ
	else {
		MainTable[0].symbol = CodeTwo->value;
		*MainTable[0].StrTable = '1';
		pit++;
	}
	free(CodeTwo);

	//End of Training
	FILE *t = fopen("out.txt", "ab");
	input = fopen("in.txt", "rb");
	fgetc(input);
	fgetc(input);
	fgetc(input);
	int c;
	BitCotx *Bitctx = calloc(1, sizeof(BitCotx));
	Bitctx->out = t;
	
	while ((c = fgetc(input)) != EOF) {
		unsigned char *code = calloc(255, sizeof(unsigned char));
		for (int r = 0; r < pit; r++) {
			if (MainTable[r].symbol == c) {
				strcpy(code, MainTable[r].StrTable);
				break;
			}
		}
		for (int r = 0; r < strlen(code); r++) {
			writeBit(code[r], Bitctx);
		}
	}

	if ((c == EOF)) {
		fputc(Bitctx->str, Bitctx->out);
		fseek(t, -INT_MAX, SEEK_SET);
		fprintf(t, "%d", 8 - (Bitctx->pos));
		
		////допилить вставку пустых битов
	}

	free(Bitctx);
	fclose(input);
	fclose(t);
	free(MainTable);


}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main() {
	FILE *in = fopen("in.txt", "r");
	char mode;
	fscanf(in, "%c", &mode);
	
	switch (mode)
	{
	case 'c': {
		
		encode(in);
		break;
	}
	case 'd': {
		
		decode(in);
		break;
	}
	default:
		printf("Help");
		break;
	}
	
	return 0;
}
