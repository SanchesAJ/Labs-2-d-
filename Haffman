#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "pqeue.h"


//////////////////////////////////////////STACK///////////////////////////////////
typedef struct _List {
	hufftreeNode *val;
	struct _List *next;
} List;
typedef struct _Stack {
	List *head;
} Stack;
typedef enum ErrorCode {
	GOOD,
	MEMORY_ERROR,
	VOID,
	NO
} Error;
List *createList(hufftreeNode *value) {
	List *l = malloc(sizeof(List));
	if (l == NULL) {
		printf("Error");
		return NULL;
	}
	l->val = value;
	l->next = NULL;
	return l;
}
Error pushStack(Stack *s, hufftreeNode *el) {
	List *l = createList(el);
	if (l == NULL)
		return MEMORY_ERROR;
	l->next = s->head;
	s->head = l;
	return GOOD;
}
int isEmptyStack(Stack *f) {
	return f->head == NULL ? 1 : 0;
}
char peekStack(Stack *s) {
	if ((s->head->val) == NULL)
		return NULL;
	else
		return s->head->val;
}
Error popStack(Stack *s, hufftreeNode *a) {
	if (s->head == NULL)
		return VOID;
	a = s->head->val;
	List *oldHead = s->head;
	s->head = s->head->next;
	free(oldHead);
	return GOOD;
}
//////////////////////////////////////////////////////////////////////////////////



typedef struct _bitCotx {
	int pos;
	unsigned char str;
	FILE *out;
} BitCotx;


////////////////////////////////////////////////////////////TRAINING/////////////////////////////////////////////////////////////////////////
typedef struct _BinTable {
	unsigned char symbol;
	unsigned char StrTable[100];
} BinTable;

hufftreeNode *CreateCodeTree(Pqueue *templ) {
	while (!isLast(&templ)) {
		hufftreeNode *One = pop(&templ);
		hufftreeNode *Two = pop(&templ);
		push(&templ, NULL, (One->priority) + (Two->priority), One, Two);
	}
	return pop(&templ);
}
hufftreeNode *Training(FILE *input) {
	//Устанавливаем частоту символов
	int Alphabet[257];
	for (int i = 0; i < 256; i++)
		Alphabet[i] = 0;
	int j = 0;
	while (!feof(input)) {
		int temp = fgetc(input);
		
		for (j = 0; j < 256; ++j) {
			if (temp == j) {
				++Alphabet[j];
				break;
			}
		}
	}
	Alphabet[j]--;


	// Создание очереди.
	int i; Pqueue *Collum = NULL;
	for (i = 0; i < 256; ++i) {
		if (Alphabet[i] != 0) {
			Collum = newPqueue(i, Alphabet[i], NULL, NULL);
			break;
		}
	}
	if (Collum == NULL) {
		exit(0);
	}
	int y = 0;
	for (i = 0; i < 256; ++i) {
		if (Alphabet[i] != 0) {
			push(&Collum, i, Alphabet[i], NULL, NULL);
			y++;
		}
	}

	pop(&Collum);
	//// Создаём дерево
	return CreateCodeTree(Collum);;
}
int count = 0;
void printTree(hufftreeNode *Tree, FILE *output) {
	if (Tree->value == '\0') {
		fputc('0', output);
	}

	if ((Tree->left) != NULL) {
		if (Tree->left->value == '\0') {
			fputc('0', output);
			printTree(Tree->left->left, output);
			printTree(Tree->left->right, output);
		}
		else {
			if (Tree->left->value != '\0') {
				fputc('1', output);
				fputc(Tree->left->value, output);
				count++;

			}
		}


	}
	else {
		if (Tree->value != '\0') {
			fputc('1', output);
			fputc(Tree->value, output);
			count++;
			return;
		}
	}

	if ((Tree->right) != NULL) {
		if (Tree->right->value == '\0') {

			//fprintf(output, "0");
			fputc('0', output);
			//printf("0");
			printTree(Tree->right->left, output);
			printTree(Tree->right->right, output);
		}
		else {
			if (Tree->right->value != '\0') {
				//fprintf(output, "1");// Код "Создай лист"
				fputc('1', output);
				//printf("1");
				//printf("%c", Tree->right->value);
				fputc(Tree->right->value, output);
				//fprintf(output, "%c", Tree->right->value);
				count++;

			}
		}

	}
	else {
		if (Tree->value != '\0') {
			//fprintf(output, "1");// Код "Создай лист"
			fputc('1', output);
			//printf("1");
			//printf("%c", Tree->value);
			fputc(Tree->value, output);
			//fprintf(output, "%c", Tree->value);
			count++;
			return;
		}
	}
	return;
}
int coin; unsigned char str[256]; int pit = 0;
void CreateCodeTable(hufftreeNode *Tree, BinTable *Table, int num) {
	coin = num;
	if ((Tree->left) != NULL) {
		if (coin < 0)
			coin++;
		str[coin] = '0';
		coin++;
		if (Tree->left->value == '\0') {
			str[coin] = '0';
			coin++;
			CreateCodeTable(Tree->left->left, Table, coin);

			str[coin] = '1';
			coin++;

			CreateCodeTable(Tree->left->right, Table, coin);
			coin--;
			if (coin >= 0)
				str[coin] = '\0';
		}
		else {
			if (Tree->left->value != '\0') {
				Table[Tree->left->value].symbol = Tree->left->value;
				strcpy(Table[Tree->left->value].StrTable, str);
				pit++;
				coin--;
				if (coin >= 0)
					str[coin] = '\0';

			}
		}
	}
	else {
		if (Tree->value != '\0') {


			str[coin] = '\0';
			Table[Tree->value].symbol = Tree->value;
			strcpy(Table[Tree->value].StrTable, str);
			//printf("%c %s\n", Tree->value, str);
			pit++;
			coin--;
			if (coin >= 0)
				str[coin] = '\0';
			return;
		}
	}

	if ((Tree->right) != NULL) {
		if (coin < 0)
			coin++;
		str[coin] = '1';
		coin++;
		if (Tree->right->value == '\0') {
			str[coin] = '0';
			coin++;
			CreateCodeTable(Tree->right->left, Table, coin);
			str[coin] = '1';
			coin++;
			CreateCodeTable(Tree->right->right, Table, coin);
			if (coin >= 3) {
				coin--;
				str[coin] = '\0';
			}
			coin--;
			if (coin >= 0)
				str[coin] = '\0';
		}
		else {
			if (Tree->right->value != '\0') {
				Table[Tree->right->value].symbol = Tree->right->value;
				strcpy(Table[Tree->right->value].StrTable, str);
				//printf("%c %s\n", Tree->right->value, str);

				pit++;
				coin--;
				if (coin >= 0)
					str[coin] = '\0';

			}
		}
	}
	else {
		if (Tree->value != '\0') {

			str[coin] = '\0';
			Table[Tree->value].symbol = Tree->value;
			strcpy(Table[Tree->value].StrTable, str);
			pit++;
			coin--;
			str[coin] = '\0';
			return;
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
hufftreeNode *readTree(FILE *input, hufftreeNode *Tree) {
	hufftreeNode *node = calloc(1, sizeof(hufftreeNode));
	int c = fgetc(input);
	if (c == EOF)
		return NULL;
	count++;
	if (c == '1') {
		c = fgetc(input);
		count++;
		node = newHuffNode(c, 0, NULL, NULL);
	}
	else
	if(c=='0'){
		node = newHuffNode('\0', 0, NULL, NULL);
		node->left = readTree(input, node);
		node->right = readTree(input, node);
	}
	return node;
}
hufftreeNode *GoTree(unsigned char code, hufftreeNode *Node, FILE *out) {
	if (code == 0) {
		if (Node->left != NULL)
			Node = Node->left;
		if (Node->value != '\0') {
			fputc(Node->value, out);
			return NULL;
		}
		else return Node;
	}
	if (code == 1) {
		if (Node->right != NULL)
			Node = Node->right;
		if (Node->value != '\0') {
			fputc(Node->value, out);			
			return NULL;
		}
		else return Node;
	}
}



void decode(FILE *input) {
	hufftreeNode *Tree = NULL;
	Tree = readTree(input, NULL);
	if (Tree == NULL) {
		exit(0);
	}
	//РАБОТАЕТ

	FILE *out = fopen("out.txt", "wb");
	int c;
	int pos = 7;
	unsigned char r;
	unsigned char b;
	hufftreeNode *Temp = Tree;
	int tempNext;
	int temp;
	//fgetc(input);
	while ((c = fgetc(input)) != EOF) {
		if (c == '$') {
			c = fgetc(input);
		}
		temp = fgetc(input);
		tempNext = fgetc(input);
		fseek(input, -2, SEEK_CUR);


		if (tempNext == EOF) {
			
			if (temp <= 8 && temp > 0) {
				for (int u = 0; u < 8 - temp; u++) {
					b = (char)c;
					r = (c >> (pos - u)) % 2;
					Temp = GoTree(r, Temp, out);
					if (Temp == NULL)
						Temp = Tree;

				}
				break;
			}
		}
		for (int u = 0; u < 8; u++) {
			b = (char)c;
			r = (c >> (pos - u)) % 2;
			Temp = GoTree(r, Temp, out);
			if (Temp == NULL)
				Temp = Tree;

		}

	}
}


////////////////////////////////////////////////////////////////ENCODING///////////////////////////////////////////////////////////////////////
void writeBit(unsigned char code, BitCotx *bitCtx) {
	if (code == '1') {
		bitCtx->str |= 1 << (7 - (bitCtx->pos));
		bitCtx->pos++;
	}
	else
		bitCtx->pos++;
	if (bitCtx->pos == 8) {
		fputc(bitCtx->str, bitCtx->out);
		bitCtx->pos = 0;
		bitCtx->str = '\0';
	}

}
void encode(FILE *input) {
	//Training to main encoding
	hufftreeNode *Code = Training(input);
	fclose(input);
	FILE *out = fopen("out.txt", "wb");
	printTree(Code, out);
	fputc("\n\n",out);
	
	BinTable *MainTable = calloc(256, sizeof(BinTable));
	hufftreeNode *CodeTwo = Code;
	if (CodeTwo->value == '\0')
		CreateCodeTable(CodeTwo, MainTable, 0); //РАБОТАЕТ
	else {
		MainTable[CodeTwo->value].symbol = CodeTwo->value;
		*MainTable[CodeTwo->value].StrTable = '1';
	}
	free(CodeTwo);

	//End of Training
	input = fopen("in.txt", "rb");
	fgetc(input);
	fgetc(input);
	fgetc(input);
	int c;
	BitCotx *Bitctx = calloc(1, sizeof(BitCotx));
	Bitctx->out = out;

	while ((c = fgetc(input)) != EOF) {
		unsigned char *code = calloc(255, sizeof(unsigned char));
		strcpy(code, MainTable[c].StrTable);
		for (int r = 0; r < strlen(code); r++) {
			writeBit(code[r], Bitctx);
		}
	}

	if ((c == EOF)) {
		fputc(Bitctx->str, Bitctx->out);
		fseek(out, 0, SEEK_END);
		fputc(8 - (Bitctx->pos), out);

		////допилить вставку пустых битов
	}

	free(Bitctx);
	fclose(input);
	fclose(out);
	free(MainTable);


}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main() {
	FILE *in = fopen("in.txt", "rb");
	int mode;
	mode = fgetc(in);
	int y=fgetc(in);
	y=fgetc(in);
	switch (mode)
	{
	case 'c': {

		encode(in);
		break;
	}
	case 'd': {

		decode(in);
		break;
	}
	default:
		printf("Help");
		break;
	}

	return 0;
}
